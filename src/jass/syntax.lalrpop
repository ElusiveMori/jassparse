use std::str::FromStr;
use crate::jass::ast::*;

grammar;

// Utils

SingleComma: () = "," => ();

CommaSeparated<Rule>: Vec<Rule> =
    <rules: (<Rule> SingleComma)*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Tier<Op,NextTier>: Expr = {
    <lhs: Tier<Op,NextTier>> <op: Op> <rhs: NextTier> => Expr::BinaryOp(Box::new(lhs), op, Box::new(rhs)),
    NextTier
};

//

pub IntLiteral: i32 = {
    r"0x[0-9abcdefABCDEF]+" => {
        let mut substring = &<>[2..];
        i32::from_str_radix(substring, 16).unwrap()
    },
    r"\$[0-9abcdefABCDEF]+" => {
        let mut substring = &<>[1..];
        i32::from_str_radix(substring, 16).unwrap()
    },
    r"[0-9]+"                 => i32::from_str(<>).unwrap(),
}

pub RealLiteral: f32 = {
    r"[0-9]+\.[0-9]*" => f32::from_str(<>).unwrap(),
    r"\.[0-9]+"       => f32::from_str(<>).unwrap()
}

pub StringLiteral: String = r#"".*""# => <>.to_string();

pub IdentStr: &'input str = {
    r"[a-zA-Z_][a-zA-Z_\d]*" => <>
};

Ident: Ident = IdentStr => <>.to_string();

ArrayAccess: Expr = "[" <Expr> "]" => <>;
AssignmentRhs: Expr = "=" <Expr> => <>;

VariableAssignment: (Ident, Expr) = <vname: Ident> <assignment: AssignmentRhs> => (vname, assignment);
ArrayAssignment: (Ident, Expr, Expr) = <vname: Ident> <id: ArrayAccess> <assignment: AssignmentRhs> => (vname, id, assignment);
FunctionCall: (Ident, Vec<Expr>) = <fname: Ident> "(" <args: CommaSeparated<Expr>> ")" => (fname, args);

VariableDefinition: VariableDefinition = <vtype: Ident> <is_array: "array"?> <vname: Ident> <assignment: AssignmentRhs?> => {
    VariableDefinition {
        var_name: vname,
        var_type: vtype,
        is_array: is_array.is_some(),
        assignment: assignment
    }
};

AddSubOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

MulDivOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
};

CompOp: BinaryOp = {
    ">" => BinaryOp::GT,
    ">=" => BinaryOp::GE,
    "<" => BinaryOp::LT,
    "<=" => BinaryOp::LE,
};

EqOp: BinaryOp = {
    "==" => BinaryOp::EQ,
    "!=" => BinaryOp::NE,
}

T0Expr: Expr = {
    "(" <Expr> ")" => <>,
    StringLiteral => Expr::StringLiteral(<>),
    IntLiteral => Expr::IntLiteral(<>),
    RealLiteral => Expr::RealLiteral(<>),
    Ident => Expr::VarAccess(<>),
    <id: Ident> "[" <expr: Expr> "]" => Expr::ArrayAccess(id, Box::new(expr)),
    "null" => Expr::Null,
    FunctionCall => Expr::Call(<>.0, <>.1)
};

T1Expr = Tier<MulDivOp, T0Expr>;
T2Expr = Tier<AddSubOp, T1Expr>;
T3Expr = Tier<CompOp, T2Expr>;
T4Expr = Tier<EqOp, T3Expr>;
pub Expr = T4Expr;

// CodeStatement: CodeStatement = {
//     "set" 
// }